# Alex Sheen Computer Security 01-29-22 Assignment 2

## sploit0
**target0** uses `strcpy()` to copy `argv[1]` into `buf[16]` without checking the size of `argv[1]`.
I used an input payload larger than 16 bytes to write shellcode into `buf[]` and then overflow `buf[]` to overwrite the `eip`, return address, of `bad_echo()`. By pointing `eip` to the starting address of the shellcode, I forced `bad_echo()` to return and execute the shellcode.


## sploit1
**target1** uses `strcpy()` to copy `argv[1]` into `buf[256]` without checking the size of `argv[1]`.
I used an input payload larger than 256 bytes to write shellcode into `buf[]` and then overflow `buf[]` to overwrite the `eip`, return address, of `foo()`. By pointing `eip` to the starting address of the shellcode, I forced `foo()` to return and execute the shellcode.

## **sploit2**
**target2** incorrectly allocates `buf[200]`, such that an attack can overwrite the `eip`, return
address, by writing to the buffer.
Similar to above, I used **GDB** to find the return addresses of `foo()`, `bar()`, and `nstrcpy()`. I noticed that one of the function’s return addresses was within `buf[]`, so I wrote shellcode into `buf[]` and overwrote the return address to point to the beginning of the shellcode.

## **sploit3**
**target3** dangerously **truncates** an *integer* to a *short* when it passes *int* `input_size` into
`foo()` which expects a *short* `input_size`.
I used an input payload of a *string* “65935” as `argv[2]` which eventually becomes `input_string`. A *string* “65935” is interpreted as an *integer* 65935 by `atoi(argv[2])`. Since my main payload for `argv[1]` is 500 bytes which is less than 65935, the main payload will pass the “real_size can’t be larger than input_size” test.
Since casting an *integer* to a *short* will truncate the bits of *integer* 65935, `foo()` will read this number as *short* 399, and `input_size` will pass the “must equal 399” check. In this way, even though the two tests in **target3** are supposed to guarantee that `argv[1]` is not longer than `input_size` bytes, by exploiting this *integer->short* truncation, I am able to input a payload larger than 400 bytes. From here, the process is the same as **sploit2** and **sploit3**. I write shellcode into `buf[]`, overflow `buf[]` and overwrite `eip`, the return address of `foo()`, so that it points to the beginning of the shellcode.

## sploit4
**target4** casts an *unsigned int* to an *integer*. This is dangerous since this number is used
to check the length of the payload being written into the buffer.
The idea behind this exploit is that I can input a positive number large enough to become a negative number when **target4** casts it from an unsigned *integer* to an *integer*. This ensures that `count < MAX_WIDGETS`. However, since I ran into memory problems when I inputted an initial random large positive number, I realized that instead, I needed to reach a special number such that, when multiplied by `sizeof(widget)`, it would truncate to a small positive number. In particular, I wanted it to result in some positive n less than 20050, the size of my payload (After testing, I knew that if I picked a payload size 20050, then the `eip` of `foo()` would be at 20015, so I knew that I wanted to solve the equation:

`(count * 20) mod MAX_INT = n for n ≈ 20050`
`(count * 20) - MAX_INT * m = 20050 for some m`
`20050 = (count * 20) - MAX_INT * m`
`20050 + MAX_INT * m = count * 20`
`(20050 + MAX_INT * m) / 20 = count`

Since I knew that count would have to be a negative number, I kept increasing the value of `m` up from 1 until I reached a count that was a little larger than MAX_INT, so that it would result in a small negative number when cast as an *integer*. Eventually, I found `m = 20`, which results in `(MAX_INT * m) = 2147484649.5`, which I rounded down.
By inputting the 2147484649 as count, I was able to pass the `count < MAX_WIDGETS test`, since count is casted to a negative *integer*. Since `2147484649 * 20 mod MAX_INT = 20040`, I am able to write enough data into `buf[]` to overwrite `eip` and point to the shellcode.

## sploit5
**target5** uses `strcpy()` to copy `argv[1]` into `name[4]` without checking the size of `argv[1]`.

 Even though the stack is **non-executable**, by inputting a payload greater than 4 bytes, I am able to overflow the `name[]` buffer and overwrite the `eip`, return address, of `foo()`, setting it to the address of the `system()` call in `libc`. I input `“/bin/sh”` as an **env** variable and point to its address on the stack. By putting this after `eip` and the return address for the `system()` call, I am able to put `“/bin/sh”` as the parameter for the `system()` call, spawning a new shell. I also set the return address for the new system call to be the address of the `exit()` call in libc. This allows me to exit the shell gracefully.
 
Sources:
https://css.csail.mit.edu/6.858/2017/readings/return-to-libc.pdf https://www.exploit-db.com/docs/english/28553-linux-classic-return-to-libc-&-return-to-lib c-chaining-tutorial.pdf
   